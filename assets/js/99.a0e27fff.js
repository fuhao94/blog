(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{681:function(l,v,_){"use strict";_.r(v);var e=_(13),o=Object(e.a)({},(function(){var l=this,v=l.$createElement,_=l._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[_("ul",[_("li",[l._v("初始化：开始构建，读取与合并配置参数，加载plugin，实例化编译器对象 compiler。")]),l._v(" "),_("li",[l._v("编译：从entry出发，每个module串行的调用对应的loader，查找每个module依赖的module，递归的进行编译过程")]),l._v(" "),_("li",[l._v("输出：把module组合成chunk，转换为文件，输出到文件系统。")])]),l._v(" "),_("hr"),l._v(" "),_("p",[l._v("-------------------------------- 2021.06.19 --------------------------------")]),l._v(" "),_("ol",[_("li",[l._v("初始化参数，webpack.config.js 的 module.export ，结合默认参数，merge 出最终的参数。")]),l._v(" "),_("li",[l._v("开始编译: 用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译;")]),l._v(" "),_("li",[l._v("确定入口: 根据配置中的 entry 找出所有的入口文件;")]),l._v(" "),_("li",[l._v("编译模块: 从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，\n再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理;")]),l._v(" "),_("li",[l._v("完成模块编译: 在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内\n容以及它们之间的依赖关系;")]),l._v(" "),_("li",[l._v("输出资源:根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个\nChunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会;")]),l._v(" "),_("li",[l._v("输出完成:在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系\n统。")])]),l._v(" "),_("ul",[_("li",[l._v("你刚说的输出列表是什么？ - 其实是在问 "),_("code",[l._v("chunks")]),l._v(" 是挂在哪个对象上。")]),l._v(" "),_("li",[l._v("入口模块是怎么处理的？ - 其实在问如何生成入口模块的")]),l._v(" "),_("li",[l._v("最后是怎么把文件内容写入到文件系统的？ - 其实是在问 "),_("code",[l._v("compiler")]),l._v(" 是如何具备文件读写能力的")]),l._v(" "),_("li",[l._v("什么时候构建阶段开始？ - 其实是在问webpack开始构建之前做了哪些构建准备")]),l._v(" "),_("li",[l._v("你说的调用Loader对模块进行翻译是如何做到的？ - 其实是在问在哪个阶段处理 "),_("code",[l._v("loader")]),l._v(" 的")])])])}),[],!1,null,null,null);v.default=o.exports}}]);