(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{454:function(t,e,n){"use strict";n.r(e);var a=n(0),v=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"事件机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件机制"}},[t._v("#")]),t._v(" 事件机制")]),t._v(" "),e("h2",{attrs:{id:"dom事件流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dom事件流"}},[t._v("#")]),t._v(" DOM事件流")]),t._v(" "),e("p",[t._v("事件流(Event Flow)指的就是「网页元素接收事件的顺序」。事件流可以分成两种机制：")]),t._v(" "),e("ul",[e("li",[t._v("事件捕获(Event Capturing)")]),t._v(" "),e("li",[t._v("事件冒泡(Event Bubbling)\n当一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段：")])]),t._v(" "),e("ol",[e("li",[t._v("捕获阶段：事件从window对象自上而下向目标节点传播的阶段；")]),t._v(" "),e("li",[t._v("目标阶段：真正的目标节点正在处理事件的阶段；")]),t._v(" "),e("li",[t._v("冒泡阶段：事件从目标节点自下而上向window对象传播的阶段。")])]),t._v(" "),e("h2",{attrs:{id:"事件监听"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件监听"}},[t._v("#")]),t._v(" 事件监听")]),t._v(" "),e("p",[e("strong",[t._v("EventTarget.addEventListener()")])]),t._v(" "),e("p",[t._v("addEventListener()基本上有三个参数，分别是「事件名称」、「事件的处理程序」(事件触发时执行的function)，以及一个「Boolean」值，由这个Boolean决定事件是以「捕获」还是「冒泡」机制执行，若不指定则预设为「冒泡」。")]),t._v(" "),e("p",[t._v("由于addEventListener()可以同时针对某个事件绑定多个函数，所以通过removeEventListener()解除事件的时候，第二个参数的函数必须要与先前在addEventListener()绑定的函数是同一个「实体」。")])])}),[],!1,null,null,null);e.default=v.exports}}]);