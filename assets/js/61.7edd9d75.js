(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{476:function(t,e,s){"use strict";s.r(e);var a=s(0),r=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"npm-install-工作流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#npm-install-工作流程"}},[t._v("#")]),t._v(" npm install 工作流程")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("确定首层依赖")]),t._v("：检查 package.json, 检查 dependencies、devDependencies 中指定模块")]),t._v(" "),e("li",[e("strong",[t._v("构建依赖树")]),t._v("：递归构建依赖树；如果有 lock 文件，直接使用里面版本号，没有则从远处拉取。例：xxx^1.0.0，则会拉取 1.x.x 最新版本")]),t._v(" "),e("li",[e("strong",[t._v("依赖树扁平化")]),t._v("：为了防止重复模块(A依赖moment B也依赖moment)的情况，会遍历所有的模块放到根节点下面，如果有重复模块则直接舍弃。\n"),e("ul",[e("li",[t._v("比如 node_modules 下 A 模块依赖 moment@^1.0.0，B 模块依赖 moment@^1.1.0，则 ^1.1.0 为兼容版本。")]),t._v(" "),e("li",[t._v("而当 A 模块依赖 moment@^2.0.0，B 模块依赖 moment@^1.1.0，则依据 semver 的规则，二者不存在兼容版本。会将一个版本放在 node_modules 中，另一个仍保留在依赖树里。")])])]),t._v(" "),e("li",[e("strong",[t._v("获取依赖树确定的模块")]),t._v("：先会通过压缩包地址去判断是否在缓存中存在该版本模块，如果有，就直接拿过来，如果没有，就回去远程仓库下载，下载完后放入缓存，并解压放到node_modules目录中，最后会去新增或者更新lock文件。")])]),t._v(" "),e("p",[e("code",[t._v("npm ci 这个命令会完全按照工程的lock描述文件去安装依赖。要注意的是，当lock文件的描述版本不满足package.json依赖指定到semver规则时，会报错退出，并不会往下执行或者去更新lock文件。")])]),t._v(" "),e("h3",{attrs:{id:"package-lock-json-作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#package-lock-json-作用"}},[t._v("#")]),t._v(" package-lock.json 作用")]),t._v(" "),e("ul",[e("li",[t._v("锁定安装模块版本号")]),t._v(" "),e("li",[t._v("需要 V5+ 才支持 （cnpm 不支持）")])]),t._v(" "),e("h3",{attrs:{id:"vue3-0-和-vue2-0区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0-和-vue2-0区别"}},[t._v("#")]),t._v(" Vue3.0 和 Vue2.0区别")]),t._v(" "),e("p",[t._v("找了两篇随意看看... 还是喜欢 React 风格多些")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://juejin.cn/post/6967706999706353672",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue3对比Vue2"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://juejin.cn/post/6952671223989927943",target:"_blank",rel:"noopener noreferrer"}},[t._v("一文带你掌握Vue3新特性，再也不怕面试官啦~"),e("OutboundLink")],1)])]),t._v(" "),e("h3",{attrs:{id:"tree-shaking原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking原理"}},[t._v("#")]),t._v(" tree-shaking原理")]),t._v(" "),e("p",[e("strong",[t._v("本质是消除无用的JS代码")])]),t._v(" "),e("ul",[e("li",[t._v("在传统的静态编程语言编译器中，编译器可以判断出某些代码根本不影响输出，我们可以借助编译器将 "),e("code",[t._v("Dead Code")]),t._v(" 从 "),e("code",[t._v("AST")]),t._v("（抽象语法树）中删除")]),t._v(" "),e("li",[t._v("JS 是动态语言，需要借助 ES6 模块语法的静态结构，通过编译阶段的静态分析，找到没有引入的模块并打上标记，然后在压缩阶段利用像 Terser 这样的压缩工具删除这些没有用到的代码。")]),t._v(" "),e("li",[t._v("Webpack 启动的条件\n"),e("ol",[e("li",[t._v("使用 ESM 规范编写模块代码")]),t._v(" "),e("li",[t._v("配置 "),e("code",[t._v("optimization.usedExports")]),t._v(" 为 "),e("code",[t._v("true")]),t._v("，启动标记功能")]),t._v(" "),e("li",[t._v("启动代码优化功能，可以通过如下方式实现\n"),e("ol",[e("li",[t._v("配置 "),e("code",[t._v("mode = production")])]),t._v(" "),e("li",[t._v("配置 "),e("code",[t._v("optimization.minimize = true")])]),t._v(" "),e("li",[t._v("提供 "),e("code",[t._v("optimization.minimizer")]),t._v(" 数组")])])])])])]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// webpack.config.js")]),t._v("\nmodule"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("entry")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"./src/index"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("mode")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"production"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("devtool")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("optimization")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("usedExports")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br")])]),e("h3",{attrs:{id:"css-loader-style-loader区别-自己是否写过-loader"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css-loader-style-loader区别-自己是否写过-loader"}},[t._v("#")]),t._v(" css-loader style-loader区别 自己是否写过 loader")]),t._v(" "),e("ul",[e("li",[t._v("默认 webpack 只解析 js 代码，css-loader 可以帮我们解析 css 代码（解析完后未挂载）")]),t._v(" "),e("li",[t._v("style-loader 就是帮我们直接将 css-loader 解析后的内容挂载到 html 页面当中")])]),t._v(" "),e("h3",{attrs:{id:"什么是微服务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是微服务"}},[t._v("#")]),t._v(" 什么是微服务")]),t._v(" "),e("ol",[e("li",[t._v("使用 HTTP 服务器的路由来重定向多个应用（也就是链接跳转）")]),t._v(" "),e("li",[t._v("在不同的框架之上设计通讯、加载机制，诸如 Mooa 和 Single-SPA")]),t._v(" "),e("li",[t._v("通过组合多个独立应用、组件来构建一个单体应用")]),t._v(" "),e("li",[t._v("iFrame。使用 iFrame 及自定义消息传递机制")]),t._v(" "),e("li",[t._v("使用纯 Web Components 构建应用")]),t._v(" "),e("li",[t._v("结合 Web Components 构建")])]),t._v(" "),e("p",[t._v("看看 "),e("code",[t._v("single spa")]),t._v(" 和 "),e("code",[t._v("qiankun")]),t._v(" 。。。")]),t._v(" "),e("h3",{attrs:{id:"怎么检测性能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#怎么检测性能"}},[t._v("#")]),t._v(" 怎么检测性能")]),t._v(" "),e("p",[e("code",[t._v("React Profiler")]),t._v(" 和 "),e("code",[t._v("Performance")]),t._v(" ...")]),t._v(" "),e("h3",{attrs:{id:"babel-解析过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#babel-解析过程"}},[t._v("#")]),t._v(" babel 解析过程")]),t._v(" "),e("ol",[e("li",[t._v("parse(解析)")])]),t._v(" "),e("p",[t._v("原始代码拆分成 Tokens 交给 tokenizer(分词器) 调用，将 Tokens 重新格式化为 AST(抽象语法树)")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("transform(转换)")])]),t._v(" "),e("p",[t._v("对 AST 进行增删改查")]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("generate(生成)")])]),t._v(" "),e("p",[e("strong",[t._v("总结")]),t._v(": 词法分析 => Tokens => 句法分析 => AST => 转化阶段对 AST 进一步分析 => 最后是代码生成阶段 => 返回字符串形式的代码。")]),t._v(" "),e("h3",{attrs:{id:"get-reset-的-hard、soft-和-mixed-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#get-reset-的-hard、soft-和-mixed-区别"}},[t._v("#")]),t._v(" get reset 的 hard、soft 和 mixed 区别")]),t._v(" "),e("ul",[e("li",[t._v("--soft # 还原 HEAD")]),t._v(" "),e("li",[t._v("--mixed # 还原 HEAD、Index # 默认参数")]),t._v(" "),e("li",[t._v("--hard # 还原 HEAD、Index、Working Directory")])]),t._v(" "),e("h3",{attrs:{id:"二叉树、防抖、json-stringify"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉树、防抖、json-stringify"}},[t._v("#")]),t._v(" 二叉树、防抖、JSON.stringify")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://fuhao94.github.io/blog/blogs/learning/202106.html#debounce",target:"_blank",rel:"noopener noreferrer"}},[t._v("debounce"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://fuhao94.github.io/blog/blogs/learning/JS%E5%9F%BA%E7%A1%80.html#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8C%96%E7%89%88%E6%9C%AC-json-stringify",target:"_blank",rel:"noopener noreferrer"}},[t._v("JSON.stringify"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"hooks-作用-解决了什么问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hooks-作用-解决了什么问题"}},[t._v("#")]),t._v(" hooks 作用 || 解决了什么问题")]),t._v(" "),e("ul",[e("li",[t._v("解决的问题\n"),e("ol",[e("li",[t._v("函数组件没有state")]),t._v(" "),e("li",[t._v("函数组件没有生命周期")])])]),t._v(" "),e("li",[t._v("有点\n"),e("ol",[e("li",[t._v("hooks 使你在无需修改组件结构的情况下复用状态逻辑")]),t._v(" "),e("li",[t._v("hooks 将组件中相互关联的部分拆分成更小的函数，并且使你在非 class 的情况下可以使用更多的 React 特性")]),t._v(" "),e("li",[t._v("React 组件一直更像是函数，而 hooks 则拥抱了函数")])])])]),t._v(" "),e("h3",{attrs:{id:"性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),e("p",[e("a",{attrs:{href:"http://localhost:8081/blog/blogs/learning/202109.html#http%E5%B1%82%E9%9D%A2%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96",target:"_blank",rel:"noopener noreferrer"}},[t._v("性能优化"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);