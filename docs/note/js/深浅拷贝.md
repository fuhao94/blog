# 深浅拷贝

## 深拷贝

> Object.freeze() Object.assign() 都是浅拷贝

### 简易实现

```js
function cloneDeep(obj) {
    if(typeof obj !== 'object') return obj;

    let newObj = obj instanceof Array ? [] : {}

    for (let key in obj) {
        if(typeof obj[key] === 'object') {
            newObj[key] = cloneDeep(obj[key])
        } else {
            newObj[key] = obj[key];
        }
    }

    return newObj;
}
```

## 判断两个对象是否相等

### 转化成字符串比较方式
JSON.stringify()首先，我们可以通过将对象通过JSON.stringify()方法将对象转换成字符串，然后再比较
局限性：
如果对象里属性的位置发生变化，转换来的字符串就不相等，但实际我们只需要看他们的内容是否一致，与顺序没有关系，所以这种方法有局限性。

### 简易版实现

首先判断是不是引用类型的，如果有一个不是，那就进行直接判断。
若全是引用类型的，那就先看一下属性值的长度是否相等，若不相等，就直接false啦。
若相等，就接着遍历里边的每一个属性，还是先看里边的属性是哪一个类型，如果全是引用类型，那就接着对里边的属性调用equals递归函数。如果不全是引用类型，那就比较这两个值是否相等，若不相等就直接false啦。
若遍历一圈下来都没有返回false，说明都相等啦。所以返回true。

```js
function equals(x,y){
    var f1=x instanceof Object;
    var f2=y instanceof Object;
    if(!f1 || !f2){
        return x===y
    }
    if(Object.keys(x).length!== Object.keys(y).length){
        return false
    }
    for(var p in x){
        var a= x[p] instanceof Object; 
        var b= y[p] instanceof Object; 
        if(a && b){
            equals(x[p],y[p])
        }else if(x[p]!=y[p]){
            return false;
        }
    }
      return true;
}
```


