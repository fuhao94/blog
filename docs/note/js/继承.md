# 继承的几种方式

## 构造函数

这里使用的原理就是在Child里面,把Parent的this指向改为是Child的this指向,从而实现继承

缺点:只能解决属性的继承,使用属性的值不重复,但是父级类别的方法不能继承

```js
function Parent(name) {
    this.name=name;

    Parent.prototype.saiHi=function(){
        console.log("hello")
    }
    
    function Child(name,age,gender){
        Parent.call(this,name);
        this.age=age;
        this.gender=gender;
    }
    let child=new Child("王磊",20,"男")
    console.log(child.name);// 王磊
    child.sayHi(); // Uncaught TypeError:child.sayHi is not a function
}
```

## 原型链实现继承

把Child的原型改为是Parent的实例,从而实现继承

缺点:因为Child的原型对象都是New Parent,所以实例化出来的对象的属性都是一样的,而且Parent上面的引用类型只要有一个实例对象修改了,其他也会跟着修改.因为他们原型对象都是共用的

```js
function Parent(name,gender){
    this.name=name;
    this.gender=gender;
    this.list=[1,2,3]
}
Parent.prototype.eat=function(){
    console.log("晚餐时间到")
}
function Child(age){
    this.age=age;
}
Child.prototype=new Parent("李白","男");

var child=new Child(20);
var child2=new Child(30);

child.list.push(4)
console.log(child.list);// [1,2,3,4]        
console.log(child2.list);// [1,2,3,4]
```

## 引用

![原文](https://www.cnblogs.com/cythia/p/11175343.html)