# 类型判断

## 判断两个对象是否相等

### 转化成字符串比较方式
JSON.stringify()首先，我们可以通过将对象通过JSON.stringify()方法将对象转换成字符串，然后再比较
局限性：
如果对象里属性的位置发生变化，转换来的字符串就不相等，但实际我们只需要看他们的内容是否一致，与顺序没有关系，所以这种方法有局限性。

### 简易版实现

首先判断是不是引用类型的，如果有一个不是，那就进行直接判断。
若全是引用类型的，那就先看一下属性值的长度是否相等，若不相等，就直接false啦。
若相等，就接着遍历里边的每一个属性，还是先看里边的属性是哪一个类型，如果全是引用类型，那就接着对里边的属性调用equals递归函数。如果不全是引用类型，那就比较这两个值是否相等，若不相等就直接false啦。
若遍历一圈下来都没有返回false，说明都相等啦。所以返回true。

```js
function equals(x,y){
    var f1=x instanceof Object;
    var f2=y instanceof Object;
    if(!f1 || !f2){
        return x===y
    }
    if(Object.keys(x).length!== Object.keys(y).length){
        return false
    }
    for(var p in x){
        var a= x[p] instanceof Object; 
        var b= y[p] instanceof Object; 
        if(a && b){
            equals(x[p],y[p])
        }else if(x[p]!=y[p]){
            return false;
        }
    }
      return true;
}
```

## 判断是否是数组类型

```js
/**
 * 面试官期望的答案
 */
function isArray(str){
    return Object.prototype.toString.call(str) === "[object Array]";
}
```

扩展答案

```js
[].slice // 能力判断

[] instanceof Array //类型判断

[].proto === Array.prototype

Array.isArray([]) // 存在兼容问题
```
