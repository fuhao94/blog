---
title: 招人啦~
date: 2021-05-18
keys:
- '670b14728ad9902aecba32e22fa4f6bd'
---

## JS

1. 宏任务、微任务

```js
new Promise(resolve => {
  console.log(1)
}).then(() => console.log(2)).then(console.log(3));
console.log(4);
```

答案：

`
1 3 4 undefined
`

2. 原型链

```js
function Foo() {
  getName = function () {
    alert(1);
  };
  return this;
}

Foo.getName = function () {
  alert(2);
};
Foo.prototype.getName = function () {
  alert(3);
};
var getName = function () {
  alert(4);
};

function getName() {
  alert(5);
}

Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
```

答案：

```js
Foo.getName();            // 2
getName();                // 4
Foo().getName();          // 1
getName();                // 1
new Foo.getName();        // 2
new Foo().getName();      // 3
new new Foo().getName();  // 3
```

3. once

```js
function test(n) {
  return n*n;
}

const fn = once(test);
fn(1); // 1
fn(2); // 1
```

```js
function once(fn) {
  let run = true;
  let result;

  return function () {
    if (run) {
      return result;
    }
    result = fn.apply(this, arguments);
    return result;
  }
}
```

4. 深拷贝

```js
function cloneDeep(obj, map = new Map()) {
  if (typeof obj === 'object' && obj !== null) {
    let res = Array.isArray(obj) ? [] : {};
    const symbols = Object.getOwnPropertySymbols(obj);
    if (symbols.length > 0) {
      symbols.forEach(sym => {
        res[sym] = obj[sym];
      });
    }
    if (map.get(obj)) {
      return map.get(obj);
    }
    Object.keys(obj).forEach(key => {
      res[key] = cloneDeep(obj[key], map)
    });
    map.set(obj, res);
    return res;
  } else {
    return obj;
  }
}
```

5. groupBy

```js
const dataSource = [
  {
    name: '张三',
    age: '18',
    sex: 'male'
  },
  {
    name: '李红',
    age: '16',
    sex: 'female'
  }
];

groupBy(dataSource) // { male: [{name: '张三', ...}], female: [{name: '李红', ...}] }
```

6. sleep

```js
await sleep(3000);
console.log('sleep'); // 3秒后打印 'sleep'
```

```js
export const sleep = timeout =>
  new Promise(resolve => {
    setTimeout(resolve, timeout);
  });
```

7. 多次请求，只取最后一次数据

* cancel request (XMLHttpRequest - cancel; axios - cancelToken)
* 记录 requestId 渲染最后一个请求数据

8. 前端路由
9. 缓存方式有哪些？
10. 防抖节流使用场景，如何实现
11. Map、Set、Symbol
12. 如何简便实现一个观察者模式

## Css

1. display: none / opacity: 0 / visibility: hidden / pointer-events: none 作用是什么?

2. 垂直居中实现方案

## Html

1. 介绍下你对浏览器内核的理解？你知道哪些内核和其所代表的浏览器呢？

## Vue

1. 生命周期介绍。DOM 在哪阶段挂载？

2. computed && watch 区别 ？

3. 请问下面代码在按下按钮的时候哪些 watch 监听器会触发。

```js
<template>
  <div>
    <p>
      <button @click="setAccount">set account</button>
    </p>
    <h2>{{account.id}} - {{account.name}} <small>{{email}}</small></h2>
  </div>
</template>
<script>
export default {
  data() {
    return {
      account: {
          name: 'test',
          email: 'test@example.com'
      }
    }
  },

  computed: {
    email() {
      return this.account.email;
    }
  },

  watch: {
    ['account.name'](name) {
      console.log('name', name);
    },
    email(email) {
      console.log('email', email);
    }
  },

  methods: {
    setAccount() {
      this.account = {id: '233', name: 'test', email: 'test@example.com'}
    }
  }
}
</script>
```

4. 按下 `add random entrie` 按钮会出现什么情况？（freeze考察）

```js
<template>
  <p>
    <button @click="addRandomEntries">add random entries</button>
  </p>
  <ul>
    <li v-for="entry in entries" :key="entry">
      {{entry}}
    </li>
  </ul>
</template>
<script>
export default {
  data() {
    return {
      entries: Object.freeze([])
    }
  },
  methods: {
    addRandomEntries() {
      this.entries.push(Math.random().toString())
    }
  },
}
</script>
```

5. 双向绑定原理

6. proxy 比较 Object.defineProperty 的优势

7. Vuex 怎么修改状态？能直接改吗？

8. diff 算法

## React

为什么生命周期不需要绑定this 事件函数需要？
   
```js
const obj = {
 name: 'Saurabh',
 display: function(){
   console.log(this.name);
  }
};

obj.display(); // 生命周期形式调用

var name = 'hello';
const outer = obj.display;
outer(); // 事件函数形式调用
```

set state里面合成事件为什么是异步的？

为什么会有 hooks ？谈谈你的理解？

hooks 如何获取上一轮的 props 或 state？

`usePrevious`

```js
function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}
```
   
生命周期方法要如何对应到 Hook ？

```js
const prevCountRef = useRef();
useEffect(() => {
  prevCountRef.current = count;
});
const prevCount = prevCountRef.current;
```

diff 算法

## TS

1. Partial 实现

## webpack

1. 热更新
2. tree-shaking
3. loader 和 plugin 区别？ 写过 loader 和 plugin 吗？

## Http

1. 常见状态码
2. keep-alive
3. cache
4. 跨域
5. 队头阻塞是什么情况会发生？http2解决后有没有缺陷？http3如何做的改进？

## 项目

1. 介绍项目
2. 难点，如何解决的？

## 其他

1. 平时如何学习的？
2. 如果看待产品频繁改需求？
