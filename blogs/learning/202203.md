---
title: 202203复习 
date: 2022-03-08 
categories:
 - 复习
---

### for...in for...of 区别

* for...in 语句以任意顺序迭代对象的`可枚举属性`。
* for...of 语句遍历`可迭代对象`定义要迭代的数据。

`for...of` 迭代对象需要手动添加一个 `iterator`

```js
Object.prototype.objCustom = function () {};
Array.prototype.arrCustom = function () {};

let iterable = [3, 5, 7];
iterable.foo = 'hello';

for (let i in iterable) {
  console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"
}

for (let i in iterable) {
  if (iterable.hasOwnProperty(i)) {
    console.log(i); // logs 0, 1, 2, "foo"
  }
}

for (let i of iterable) {
  console.log(i); // logs 3, 5, 7
}
```

### Set、Map、WeekSet、WeekMap

* Set.has() 效率比 Array.indexOf() 高
* Map: 键值对的集合（Hash 结构）
* WeakSet
  * 成员只能是对象
  * 成员都是弱引用 => 不引用会自动回收
* WeakMap
  * 只接受对象作为键名（null除外）
  * 键名所引用的对象都是弱引用 => 不引用会自动回收

### 深度、广度优先

<<< @/blogs/learning/js/dfs.js

<<< @/blogs/learning/js/bfs.js

### 原型链、继承的方法

### generate、async await

执行 `Generator` 函数会返回一个遍历器对象，调用 `next` 方法会遍历下一个内部状态，`yield` 是暂停标志

```js
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

const fn = helloWorldGenerator();

fn.next()// { value: 'hello', done: false }
fn.next()// { value: 'world', done: false }
fn.next()// { value: 'ending', done: true }
fn.next()// { value: undefined, done: true }
```

**`async` 函数的实现原理，就是将 `Generator` 函数和自动执行器，包装在一个函数里。**

```js
async function fn(args) {
  // ...
}

// 等同于
function fn(args) {
  return spawn(function* () {
    // ...
  });
}

// 自动执行器
function spawn(genF) {
  return new Promise(function (resolve, reject) {
    const gen = genF();

    function step(nextF) {
      let next;
      try {
        next = nextF();
      } catch (e) {
        return reject(e);
      }
      if (next.done) {
        return resolve(next.value);
      }
      Promise.resolve(next.value).then(function (v) {
        step(function () {
          return gen.next(v);
        });
      }, function (e) {
        step(function () {
          return gen.throw(e);
        });
      });
    }

    step(function () {
      return gen.next(undefined);
    });
  });
}
```

除了 `try...catch` 还可以这么处理 `async await` 异常

```js
export function to(promise, errorExt) {
  return promise
          .then((data) => [null, data])
          .catch((err) => {
            if (errorExt) {
              const parsedError = Object.assign({}, err, errorExt);
              return [parsedError, undefined];
            }
            return [err, undefined];
          });
}
```
